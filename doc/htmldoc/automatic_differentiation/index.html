<!DOCTYPE html><head><meta charset="UTF-8"><title>Automatic Differentiation | Aurora App</title><link href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://aurora-multiphysics.github.io/aurora/" class="left moose-logo hide-on-med-and-down" id="home-button">Aurora App</a><a href="https://github.com/aurora-multiphysics/aurora" class="right"><img src="../media/framework/github-logo.png" class="github-mark"></img><img src="../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="6cffb4d8-cb8c-4b1f-be27-dcb0f7a337f4"><i class="material-icons">menu</i></a><ul class="sidenav" id="6cffb4d8-cb8c-4b1f-be27-dcb0f7a337f4"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://aurora-multiphysics.github.io/aurora/" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="." class="breadcrumb">automatic_differentiation</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="16e4d5c8-8456-4246-942a-518f0b22a7ba" data-section-level="1" data-section-text="Automatic Differentiation"><h1 id="automatic-differentiation">Automatic Differentiation</h1><section class="scrollspy" id="f9649b39-7f38-4421-b6f5-96d562931d1e" data-section-level="2" data-section-text="Background"><h2 id="background">Background</h2><p>Historically, the most common question on the MOOSE mailing list has been &quot;why is my solve not converging?&quot; The equivalent question is also posted on the Computational Science StackExchange under the title <a href="https://scicomp.stackexchange.com/questions/30/why-is-newtons-method-not-converging">Why is Newton&#x27;s method not converging?</a> The leading bullet in the accepted answer is that the Jacobian is wrong. Coding Jacobians can be a difficult and tedious task, especially for physics that require complex material models. Instead of spending their time running simulations and generating results, physicists and engineers may sink days or weeks into constructing accurate Jacobians. Oftentimes, the developer will just throw up their hands and elect an approximate Jacobian method like <span class="moose-error">PJFNK</span> where the Jacobian is never explicitly formed but instead its action on vectors is approximated using finite differences and an approximate preconditioning matrix is hand coded for constructing an effective preconditioner. While effective in many cases, the quality of the matrix-free approximation is closely tied to selection of a differencing parameter whose size should vary based on the noisiness of the nonlinear system of equations. If the nonlinear functions are noisy and too small of a differencing parameter is chosen, truncation will lead to a Jacobian approximation that is actually a non-linear operator. If the differencing parameter is too large, then the approximated derivatives will be inaccurate if the differenced function is nonlinear. For multi-physics problems in which the magnitudes of solution and residual components may vary wildly, an arbitrary choice of differencing parameter may lead to an accurate approximation of the Jacobian action for one physics but lead to the aforementioned truncation error in another. The presence of truncation error and hence a non-linear operator is evident in a linear solve derived from porous flow equations coupled with heat transport:</p><pre class="moose-pre"><code class="language-text">
 0 KSP unpreconditioned resid norm 5.645573426379e+16 true resid norm 5.645573426379e+16 ||r(i)||/||b|| 1.000000000000e+00
 1 KSP unpreconditioned resid norm 2.965618482980e+12 true resid norm 2.965618483296e+12 ||r(i)||/||b|| 5.252997807874e-05
 2 KSP unpreconditioned resid norm 2.724648158452e+12 true resid norm 2.890172312561e+14 ||r(i)||/||b|| 5.119360061914e-03
 3 KSP unpreconditioned resid norm 8.335608026448e+11 true resid norm 5.178511494633e+15 ||r(i)||/||b|| 9.172693548605e-02
 4 KSP unpreconditioned resid norm 8.335450917197e+11 true resid norm 8.675908349302e+17 ||r(i)||/||b|| 1.536762998912e+01
 5 KSP unpreconditioned resid norm 6.022626374152e+11 true resid norm 1.028328406646e+22 ||r(i)||/||b|| 1.821477339823e+05
 6 KSP unpreconditioned resid norm 6.020981842850e+11 true resid norm 1.028926824260e+22 ||r(i)||/||b|| 1.822537316498e+05
 7 KSP unpreconditioned resid norm 2.079735227207e+11 true resid norm 6.050540886054e+21 ||r(i)||/||b|| 1.071731855932e+05
</code></pre><p>While the unpreconditioned residual norm, produced through <span class="moose-error">GMRES</span> iterations, drops by five orders of magnitude during the solve, the true residual norm computed via <span class="moose-katex-inline-equation" id="moose-equation-c8d66d0d-e7c6-4150-9090-36fdf5254871"><script>var element = document.getElementById("moose-equation-c8d66d0d-e7c6-4150-9090-36fdf5254871");katex.render("\\mathbf{A}\\vec{x} - \\vec{b}", element, {displayMode:false,throwOnError:false});</script></span> actually increases by five orders of magnitude. In MOOSE, a right preconditioned <span class="moose-error">GMRES</span> is chosen by default, where the unpreconditioned residual mathematically equal to the actual residual if the preconditioning matrix is well-conditioned. The inconsistencies generated here are, partially, because of the inaccuracy of the preconditioning matrix. The net result of such bad linear solves is a diverging Newton&#x27;s method since the computed Newton update is &quot;wrong&quot;:</p><pre class="moose-pre"><code class="language-text">
0 Nonlinear |R| = 1.138921e+06
1 Nonlinear |R| = 1.392349e+11
2 Nonlinear |R| = 2.881060e+10
3 Nonlinear |R| = 8.473409e+09
4 Nonlinear |R| = 2.017729e+09
5 Nonlinear |R| = 7.634503e+08
6 Nonlinear |R| = 5.645573e+16
Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 6
</code></pre><p>If we instead form an explicit Jacobian and eschew finite differencing, Newton&#x27;s method converges, albeit sub-quadratically since the hand-coded Jacobian is inaccurate:</p><pre class="moose-pre"><code class="language-text">
 0 Nonlinear |R| = 1.138921e+06
 1 Nonlinear |R| = 2.171654e+05
 2 Nonlinear |R| = 4.550729e+04
 3 Nonlinear |R| = 1.026123e+04
 4 Nonlinear |R| = 1.267614e+03
 5 Nonlinear |R| = 6.531982e+01
 6 Nonlinear |R| = 4.427446e-01
 7 Nonlinear |R| = 8.025639e-05
 8 Nonlinear |R| = 3.195008e-06
 9 Nonlinear |R| = 1.669770e-07
10 Nonlinear |R| = 1.201906e-08
Nonlinear solve converged due to CONVERGED_FNORM_ABS iterations 10
</code></pre><p>Given the multi-physics aim of MOOSE and the clear pitfalls associated with differencing approximations, there is clear motivation to form accurate explicit representations of the matrix. Note, even if a perfect Jacobian action can be achieved via the finite difference scheme, a suitable preconditioning matrix is required to construct a robust and efficient solver.</p><p>Some users elect to use symbolic differentiation packages like SymPy or Mathematica; however, for functions of any complexity the resulting gradient expressions can take up to several pages and can be quite difficult to translate from notebook to code. An alternative to numerical and symbolic differentiation is <span class="moose-error">AD</span>, which applies the chain rule to elementary operations at every step of the computer program and which applies at most a small constant factor (estimated to have an upper bound of 5) of additional arithmetic operations. Weighed against the untold number of developer hours sunk into attempting to create accurate hand-coded Jacobians and analyst hours spent waiting for problems with poor hand-coded or approximated Jacobians to converge, the small additional CPU cost imposed by <span class="moose-error">AD</span> seemed well worth the trade. With an accurate Jacobian formed using <span class="moose-error">AD</span>, the overall simulation  can be much faster than that utilizing a deficient hand-coded matrix. Having elected to pursue AD, there was a choice between forward and reverse modes. Forward mode <span class="moose-error">AD</span> is best suited for problems with many more outputs than inputs; reverse mode is best suited for many more inputs than outputs. The latter case is more prevalent in deep learning applications and is what is implemented in popular machine learning libraries like PyTorch. In solution of nonlinear systems of equations the number of inputs and outputs are equivalent, so the choice is not clear-cut. However, given the architecture of MOOSE in which the residuals are constructed from finite element solutions, which themselves are naturally constructed from the nonlinear degrees of freedom, forward propagation was the logical choice. Forward-mode AD relies on the concept of <code>DualNumbers</code> which can be implemented either through source code transformation or operator overloading. The latter is more easily implemented in programming languages that support it such as C++, the language that MOOSE is written in. Conveniently, the C++ header-only library MetaPhysicL came ready-made with a <code>DualNumber</code>  template class and an operator-overload <span class="moose-error">AD</span> implementation that fit into the MOOSE architecture with minimal disruption to the code-base. The <span class="moose-error">AD</span> capability of MetaPhysicL was merged into the MOOSE code-base in the fall of 2018.</p></section><section class="scrollspy" id="493107d1-883a-4a30-9fdb-6ab55bae90a1" data-section-level="2" data-section-text="AD implementation - MetaPhysicL"><h2 id="ad-implementation-metaphysicl">AD implementation - MetaPhysicL</h2><p>The automatic differentiation classes in MetaPhysicL were originally developed and tested in the Manufactured Analytical Solution Abstraction (<code>MASA</code>) library, used for generating manufactured solution tests for increasingly complicated physics simulations, when it was discovered that multiple symbolic differentiation packages were suffering software failures on sufficiently large problems.  Symbolically differentiating manufactured solution fields through e.g.\ 3-D Navier-Stokes physics caused a combinatorial explosion, leading to corresponding forcing functions that were hundreds of kilobytes in length, or required many man-hours of manual simplification, or failed altogether on some Computer Algebra System software.  Automatic differentiation allowed for the generation of manufactured solution forcing functions using code that was hardly more complex than the physics equations themselves. The classes used for this effort were eventually published as an independent library, MetaPhysicL, for wider use and further development.</p><p><code>DualNumber</code> is the centerpiece class of the automatic differentiation capability. It stores <code>value</code> and <code>derivatives</code> members which correspond to <span class="moose-katex-inline-equation" id="moose-equation-f9a588e4-10a0-43a7-ba79-368336ab55dd"><script>var element = document.getElementById("moose-equation-f9a588e4-10a0-43a7-ba79-368336ab55dd");katex.render("f(\\vec{x})", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-99e2845a-5785-4a26-a3ed-552b5c3ad9fe"><script>var element = document.getElementById("moose-equation-99e2845a-5785-4a26-a3ed-552b5c3ad9fe");katex.render("\\nabla f(\\vec{x})", element, {displayMode:false,throwOnError:false});</script></span> respectively. <code>value</code> and <code>derivatives</code> types are determined by <code>T</code> and <code>D</code> template parameters, where <code>T</code> is some floating point type, and <code>D</code> is equivalent to <code>T</code> for single-argument functions or equal to some container type for a generic vector of arguments. MetaPhysicL overloads binary arithmetic operators (<code>+,-,*,/</code>), unary functions (<code>std::sin, std::cos, std::exp</code> etc.), and binary functions (<code>std::pow, std::max, std::min</code> etc.), ensuring that any calculation involving a <code>DualNumber</code> propagates both the function value and its derivatives.</p><p>MOOSE leverages one of two MetaPhysicL container class templates depending on user configuration. The default MOOSE configuration uses the <code>NumberArray</code> class template which accepts <code>std::size_t N</code> and <code>typename T</code> template arguments where <code>N</code> denotes the length of an underlying C-array that holds the <code>NumberArray</code> data and <code>T</code> is the floating-point type held by the C-array. As for <code>DualNumber</code>, MetaPhysicL provides arithmetic, unary, and binary function overloads for manipulation of its container types. <code>NumberArray</code> is an ideal derivative container choice when there is dense coupling between physics variables; this is because operator and function overloads for <code>NumberArray</code> operate on the entire underlying C-array. The second MetaPhysicL container class leveraged by MOOSE is <code>SemiDynamicSparseNumberArray</code>, which is a more ideal choice for problems in which variable coupling is sparse or when a user wishes to solve a variety of problems with a single library configuration. In contrast to <code>NumberArray</code> which only holds a single C-array of floating-type data, <code>SemiDynamicSparseNumberArray</code> additionally holds an array (as a <code>std::array</code>) of integers corresponding to dof indices. The existence of this additional data member enables sparse operations that may involve only a subset of the elements in the underlying floating-point data. As an explicit example of when these sparse operations are useful, consider a user who may configure MOOSE with an underlying derivative storage container size of 81 for solid mechanics simulations on 3D second-order hexagonal finite elements (3 displacement variables * 27 degrees of freedom per variable per finite element = 81 local dofs). When running 3D, second-order cases, the non-sparse <code>NumberArray</code> container would be 100\% efficient. However, if the user wishes to run a 2D, second-order case with the same MOOSE configuration, they would be performing <span class="moose-katex-inline-equation" id="moose-equation-cd10f570-5228-496f-9cd6-9b67f54f5011"><script>var element = document.getElementById("moose-equation-cd10f570-5228-496f-9cd6-9b67f54f5011");katex.render("81 / 18 = 4.5", element, {displayMode:false,throwOnError:false});</script></span> times more work than is necessary if using <code>NumberArray</code>. Because <code>SemiDynamicSparseNumberArray</code> tracks the sparsity pattern, it will only initialize and operate on the floating-point array elements that are required, e.g. the <code></code>sparse size&#x27;&#x27; (stored as a <code>_dynamic_N</code> data member) of its data containers will never exceed what is required for the run-time problem, e.g. 18 for the 2D second-order solid mechanics example. Of course tracking the sparsity pattern has non-zero cost, so if the user knows they will always be running a certain kind of problem, they may be best served by configuring with non-sparse <code>NumberArray</code> container.</p></section><section class="scrollspy" id="d78e6952-8216-438d-b833-6400eb8a58fe" data-section-level="2" data-section-text="AD in MOOSE"><h2 id="ad-in-moose">AD in MOOSE</h2><p>As mentioned in above, MetaPhysicL is a forward-mode <span class="moose-error">AD</span> package. For a finite element framework like MOOSE derivative seeding begins when constructing local finite element solutions. The finite element solution approximation is given by <span class="moose-katex-inline-equation" id="moose-equation-0a24412f-2c03-4877-8fa3-92ed98238ace"><script>var element = document.getElementById("moose-equation-0a24412f-2c03-4877-8fa3-92ed98238ace");katex.render("u_h = \\sum_i^Nu_i\\phi_i", element, {displayMode:false,throwOnError:false});</script></span> where the <span class="moose-katex-inline-equation" id="moose-equation-d84ebe89-4e7c-484b-8e64-9f3cc3a549c5"><script>var element = document.getElementById("moose-equation-d84ebe89-4e7c-484b-8e64-9f3cc3a549c5");katex.render("u_i's", element, {displayMode:false,throwOnError:false});</script></span> represent the degrees of freedom and the <span class="moose-katex-inline-equation" id="moose-equation-44395041-bea6-4721-9537-2b0622bd069b"><script>var element = document.getElementById("moose-equation-44395041-bea6-4721-9537-2b0622bd069b");katex.render("\\phi_i's", element, {displayMode:false,throwOnError:false});</script></span> are shape functions associated with the dofs. For a Lagrange basis, shape functions and dofs are tied to mesh nodes. To illustrate initiation of the AD process, we will consider construction of a local finite element solution on a <code>QUAD4</code> element, that is to say a quadrilaterial with a number of nodes equal to the number of vertices. This element type when combined with a Lagrange basis has four dofs which contribute to the local solution, one for each element node. In MOOSE we assign these local degree of freedom solution values (the local <span class="moose-katex-inline-equation" id="moose-equation-1e27aecf-53e2-45c1-ab3b-868674b07fb7"><script>var element = document.getElementById("moose-equation-1e27aecf-53e2-45c1-ab3b-868674b07fb7");katex.render("u_i's", element, {displayMode:false,throwOnError:false});</script></span>) to a variable class data member called <code>_ad_dof_values</code> where the <code>ad</code> prefix denotes automatic differentiation. We then seed a derivative value of <span class="moose-katex-inline-equation" id="moose-equation-9a3381d8-2ea7-4655-94d5-021f0b17d228"><script>var element = document.getElementById("moose-equation-9a3381d8-2ea7-4655-94d5-021f0b17d228");katex.render("1", element, {displayMode:false,throwOnError:false});</script></span> (recognizing that <span class="moose-katex-inline-equation" id="moose-equation-5d008b3b-7bc3-4c85-9aa4-4ed52a4084a3"><script>var element = document.getElementById("moose-equation-5d008b3b-7bc3-4c85-9aa4-4ed52a4084a3");katex.render("\\frac{\\partial u_i}{\\partial u_j} = 1", element, {displayMode:false,throwOnError:false});</script></span> when <span class="moose-katex-inline-equation" id="moose-equation-ecee6543-1821-4d97-91cb-915d57342c9f"><script>var element = document.getElementById("moose-equation-ecee6543-1821-4d97-91cb-915d57342c9f");katex.render("i = j", element, {displayMode:false,throwOnError:false});</script></span>)  at a corresponding local dof index determined through a somewhat arbitrary numbering scheme. We choose a variable major numbering scheme such that the local degrees of freedom are in a contiguous block for each variable, e.g. if we have two variables in the system, <span class="moose-katex-inline-equation" id="moose-equation-e8aaaf34-2b63-4a21-a556-99b9a6536c26"><script>var element = document.getElementById("moose-equation-e8aaaf34-2b63-4a21-a556-99b9a6536c26");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-8edb71eb-c354-4dcc-8bec-492b6b068362"><script>var element = document.getElementById("moose-equation-8edb71eb-c354-4dcc-8bec-492b6b068362");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span>, then the numbering scheme for a <code>QUAD4</code> element with Lagrange basis would look like <span class="moose-katex-inline-equation" id="moose-equation-5acbf001-803e-40d2-92f3-bfd7f0f08b27"><script>var element = document.getElementById("moose-equation-5acbf001-803e-40d2-92f3-bfd7f0f08b27");katex.render("u_0,u_1,u_2,u_3,v_0,v_1,v_2,v_3", element, {displayMode:false,throwOnError:false});</script></span> with subscripts corresponding to the local node number. We can examine the dependence of the local finite element solution on each degree of freedom for an arbitrary point in the domain; we know analytically the expected derivatives: <span class="moose-katex-inline-equation" id="moose-equation-43fe4c3d-4ccc-49f5-8348-e789087fa8f6"><script>var element = document.getElementById("moose-equation-43fe4c3d-4ccc-49f5-8348-e789087fa8f6");katex.render("\\frac{\\partial u_h}{\\partial u_j} = \\phi_j", element, {displayMode:false,throwOnError:false});</script></span>. For a chosen Gaussian integration point <span class="moose-katex-inline-equation" id="moose-equation-7195bc2c-19e5-4577-afa6-161371ccb46b"><script>var element = document.getElementById("moose-equation-7195bc2c-19e5-4577-afa6-161371ccb46b");katex.render("(\\xi,\\eta) = (-.577, -.577)", element, {displayMode:false,throwOnError:false});</script></span>, we know the corresponding Lagrange <span class="moose-katex-inline-equation" id="moose-equation-bd33fdfd-8e46-4616-acd0-67b2353d5d35"><script>var element = document.getElementById("moose-equation-bd33fdfd-8e46-4616-acd0-67b2353d5d35");katex.render("\\phi", element, {displayMode:false,throwOnError:false});</script></span> values: <span class="moose-katex-inline-equation" id="moose-equation-72f86edf-d934-41e2-98a2-c6ac5d2cf00d"><script>var element = document.getElementById("moose-equation-72f86edf-d934-41e2-98a2-c6ac5d2cf00d");katex.render("\\phi_0=.622,\\phi_1=.167,\\phi_2=.0447,\\phi_3=.167", element, {displayMode:false,throwOnError:false});</script></span>, and we can check and verify whether our automatically differentiated solution <code>_ad_u</code> matches:</p><pre class="moose-pre"><code class="language-text">
(lldb) p _ad_u[0]
(MetaPhysicL::DualNumber&lt;double, MetaPhysicL::SemiDynamicSparseNumberArray&lt;double, unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt;, false&gt;) $10 = {
  _val = 0
  _deriv = {
    MetaPhysicL::DynamicSparseNumberBase&lt;MetaPhysicL::DynamicStdArrayWrapper&lt;double, MetaPhysicL::NWrapper&lt;50&gt; &gt;, MetaPhysicL::DynamicStdArrayWrapper&lt;unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt;, MetaPhysicL::SemiDynamicSparseNumberArray, double, unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt; = {
      _data = {
        _data = {
          _M_elems = {
            [0] = 0.62200846792814624
            [1] = 0.16666666666666669
            [2] = 0.044658198738520456
            [3] = 0.16666666666666669
            [4] = 0
            [5] = 4.82252338622924E-317
            [6] = 4.8224680508769058E-317
            [7] = 3.9525251667299724E-323
</code></pre><p>Note that some of the unused values in indices 4&ndash;7 appear to contain garbage. This is actually desirable; it indicates that for the <code>SemiDynamicSparseNumberArray</code> container, unnecessary components of the derivative vector are left uninitialized.</p><p>We can also check variable coupling. Let us assume a reaction-type problem in which the variable <span class="moose-katex-inline-equation" id="moose-equation-ddacf56b-9a5b-4d1a-9ad1-96f90c62d1ce"><script>var element = document.getElementById("moose-equation-ddacf56b-9a5b-4d1a-9ad1-96f90c62d1ce");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> disappears at a rate directly proportional to its concentration and appears at at rate directly proportional to the concentration of the variable <span class="moose-katex-inline-equation" id="moose-equation-f9f68c09-9f87-4903-bf80-1f7bccde24fb"><script>var element = document.getElementById("moose-equation-f9f68c09-9f87-4903-bf80-1f7bccde24fb");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span>. The strong form of this residual is then simply <span class="moose-katex-inline-equation" id="moose-equation-d0f7053d-38ed-4ba2-bb3c-81ea12c1cea3"><script>var element = document.getElementById("moose-equation-d0f7053d-38ed-4ba2-bb3c-81ea12c1cea3");katex.render("u - v", element, {displayMode:false,throwOnError:false});</script></span>. Examining the derivatives of this term produced by automatic differentiation</p><pre class="moose-pre"><code class="language-text">
(lldb) p strong_residual
(MetaPhysicL::DualNumber&lt;double, MetaPhysicL::SemiDynamicSparseNumberArray&lt;double, unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt;, false&gt;) $1 = {
  _val = 0
  _deriv = {
    MetaPhysicL::DynamicSparseNumberBase&lt;MetaPhysicL::DynamicStdArrayWrapper&lt;double, MetaPhysicL::NWrapper&lt;50&gt; &gt;, MetaPhysicL::DynamicStdArrayWrapper&lt;unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt;, MetaPhysicL::SemiDynamicSparseNumberArray, double, unsigned int, MetaPhysicL::NWrapper&lt;50&gt; &gt; = {
      _data = {
        _data = {
          _M_elems = {
            [0] = 0.62200846792814624
            [1] = 0.16666666666666669
            [2] = 0.044658198738520456
            [3] = 0.16666666666666669
            [4] = -0.62200846792814624
            [5] = -0.16666666666666669
            [6] = -0.044658198738520456
            [7] = -0.16666666666666669
</code></pre><p>we see exactly what we would expect: values 0&ndash;3 corresponding to the <span class="moose-katex-inline-equation" id="moose-equation-3bc44549-1cb9-48d3-b88d-3196ffc58753"><script>var element = document.getElementById("moose-equation-3bc44549-1cb9-48d3-b88d-3196ffc58753");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> indices are equivalent to that shown in the previous lldb output whereas the values in 4&ndash;7, corresponding to the <span class="moose-katex-inline-equation" id="moose-equation-17b540d7-0e33-471d-bb4e-b71adf46d686"><script>var element = document.getElementById("moose-equation-17b540d7-0e33-471d-bb4e-b71adf46d686");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> indices, are equal to the negative of that shown in the previous lldb output. In general, the quality of automatic differention results are verified with unit testing in MetaPhysicL and using a <code>PetscJacobianTester</code> in MOOSE which compares the Jacobian produced by automatic differentiation against that generated using finite differencing of the residuals. The latter test relies on using well-scaled problems; for poorly-scaled problems floating point errors can result in a loss in accuracy of the finite-differenced Jacobian.</p><section id="bfcc7e8f-b16e-4cf2-b47a-674dc8fb568f" data-section-level="3" data-section-text="Using AD in MOOSE"><h3 id="using-ad-in-moose">Using AD in MOOSE</h3><p>Leveraging the automatic differentiation capabilities in MOOSE is as simple as inheriting from our AD base classes, e.g. <code>ADKernel, ADIntegratedBC, ADDGKernel,
ADNodalBC</code>, etc. The only method an application developer has to override is <code>computeQpResidual</code> or if deriving from <code>ADKernelGrad</code> or <code>ADKernelValue</code>, then override <code>precomputeQpResidual</code>. To couple in AD variables, the application developer should use methods like <code>adCoupledValue, adCoupledGradient,
adCoupledSecond</code> etc. inherited through the <a href="../source/interfaces/Coupleable.html"><code>Coupleable</code></a> interface. Material properties with automatic differentiation info can be created in <code>Material</code> classes by using the <code>declareADProperty</code> API. <span class="moose-error">AD</span> material properties can be retrieved in compute objects like <code>ADKernels</code> by using the <code>getADMaterialProperty</code> API. For detailed examples of <span class="moose-error">AD</span> use, the reader is encouraged to investigate the tensor mechanics, navier-stokes, and level-set modules, all of which heavily leverage MOOSE&#x27;s <span class="moose-error">AD</span> capabilities. </p></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#f9649b39-7f38-4421-b6f5-96d562931d1e" class="tooltipped" data-position="left" data-tooltip="Background">Background</a></li><li><a href="#493107d1-883a-4a30-9fdb-6ab55bae90a1" class="tooltipped" data-position="left" data-tooltip="AD implementation - MetaPhysicL">AD implementation - MetaPhysicL</a></li><li><a href="#d78e6952-8216-438d-b833-6400eb8a58fe" class="tooltipped" data-position="left" data-tooltip="AD in MOOSE">AD in MOOSE</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../js/init.js"></script><script type="text/javascript" src="../js/navigation.js"></script><script type="text/javascript" src="../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../js/search_index.js"></script><script type="text/javascript" src="../js/sqa_moose.js"></script>