<!DOCTYPE html><head><meta charset="UTF-8"><title>NonlinearSystem | Aurora App</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://aurora-multiphysics.github.io/aurora/" class="left moose-logo hide-on-med-and-down">Aurora App</a><a href="https://github.com/aurora-multiphysics/aurora" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="538825a0-4836-4321-8f11-9f76f363625a"><i class="material-icons">menu</i></a><ul class="sidenav" id="538825a0-4836-4321-8f11-9f76f363625a"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://aurora-multiphysics.github.io/aurora/" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">systems</span><a href="#" class="breadcrumb">NonlinearSystem</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="49de0755-2e68-4762-aaa0-6d7e04a1eccc" data-section-level="1" data-section-text="NonlinearSystem"><h1 id="nonlinearsystem">NonlinearSystem</h1><p>The NonlinearSystem object holds the equation system created by the normal FEM process (e.g. the Matrix and RHS vector) to be solved. Normally MOOSE uses PETSc to store and solve this system. This object is where you will find the callback routines used by the PETSc solvers.</p><ul class="browser-default"><li><p><a href="NonlinearSystem.html#newtons_method">Solving Non-linear Systems</a> </p></li><li><p><a href="NonlinearSystem.html#jacobian_definition">Jacobian Definition</a> </p></li><li><p><a href="NonlinearSystem.html#linear_methods">Solving Linear Systems</a> </p></li><li><p><a href="NonlinearSystem.html#augmenting_sparsity">Augmenting Sparsity</a></p></li></ul><p>You may find some additional documentation relevant to both <code>NonlinearSystem</code> and <code>NonlinearEigenSystem</code> in <a href="NonlinearSystemBase.html">NonlinearSystemBase</a>.</p><section class="scrollspy" id="84caaaf4-f597-4bb8-9a19-39e37ca2d23a" data-section-level="2" data-section-text="Solving Non - linear Systems"><h2 id="newtons_method">Solving Non-linear Systems</h2><p>Application of the finite element method converts PDE(s) into a system of non-linear equations, <span class="moose-katex-inline-equation" id="moose-equation-f5aef271-58d1-490d-8550-8f0fb864bd6b"><script>var element = document.getElementById("moose-equation-f5aef271-58d1-490d-8550-8f0fb864bd6b");katex.render("R_i(u_h)=0, \\qquad i=1,\\ldots, N", element, {displayMode:false,throwOnError:false});</script></span>   to solve for the coefficients <span class="moose-katex-inline-equation" id="moose-equation-db4d0c07-b11a-4ba4-a375-5c356ce8757f"><script>var element = document.getElementById("moose-equation-db4d0c07-b11a-4ba4-a375-5c356ce8757f");katex.render("u_j, j=1,\\dots,N", element, {displayMode:false,throwOnError:false});</script></span>.</p><ul class="browser-default"><li><p>Newton&#x27;s method has good convergence properties, we use it to solve this system of nonlinear equations. </p></li><li><p>Newton&#x27;s method is a &quot;root finding&quot; method: it finds zeros of nonlinear equations. </p></li><li><p>Newton&#x27;s Method in &quot;Update Form&quot; for finding roots of the scalar equation <span class="moose-katex-inline-equation" id="moose-equation-3226e53f-562d-4119-9f2d-1c4e7ed1ac87"><script>var element = document.getElementById("moose-equation-3226e53f-562d-4119-9f2d-1c4e7ed1ac87");katex.render("\\begin{array}{rl}f(x)&=0, f(x): \\mathbb{R} &\\rightarrow \\mathbb{R}\\textrm{ is given by}:\\\\ f'(x_n) \\delta x_{n+1} &= -f(x_n) \\\\ x_{n+1} &= x_n + \\delta x_{n+1}\\end{array}", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p>We don&#x27;t have just one scalar equation: we have a system of nonlinear equations. </p></li><li><p>This leads to the following form of Newton&#x27;s Method:</p><p>  <span class="moose-katex-inline-equation" id="moose-equation-d79c8d4c-b2aa-4890-b29d-2362314cce8f"><script>var element = document.getElementById("moose-equation-d79c8d4c-b2aa-4890-b29d-2362314cce8f");katex.render("\\begin{aligned}   \\mathbf{J}(\\vec{u}_n) \\delta\\vec{u}_{n+1} &= -\\vec{R}(\\vec{u}_n) \\\\   \\vec{u}_{n+1} &= \\vec{u}_n + \\delta\\vec{u}_{n+1}\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Where <span class="moose-katex-inline-equation" id="moose-equation-75ae6e8e-1bf0-425c-a2a2-ab0661dd941b"><script>var element = document.getElementById("moose-equation-75ae6e8e-1bf0-425c-a2a2-ab0661dd941b");katex.render("\\mathbf{J}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> is the Jacobian matrix evaluated at the current iterate:   <span class="moose-katex-inline-equation" id="moose-equation-69a5382f-f062-4a8f-ab8d-c09070f92447"><script>var element = document.getElementById("moose-equation-69a5382f-f062-4a8f-ab8d-c09070f92447");katex.render("J_{ij}(\\vec{u}_n) = \\frac{\\partial R_i(\\vec{u}_n)}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Note that:   <span class="moose-katex-inline-equation" id="moose-equation-38a4a2d3-1f1a-4787-9b3f-ad44c252ed2d"><script>var element = document.getElementById("moose-equation-38a4a2d3-1f1a-4787-9b3f-ad44c252ed2d");katex.render("\\frac{\\partial u_h}{\\partial u_j} =     \\sum_k\\frac{\\partial }{\\partial u_j}\\left(u_k \\phi_k\\right) = \\phi_j   \\qquad   \\frac{\\partial \\left(\\nabla u_h\\right)}{\\partial u_j} =     \\sum_k \\frac{\\partial }{\\partial u_j}\\left(u_k \\nabla \\phi_k\\right) = \\nabla \\phi_j", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section><section class="scrollspy" id="a348960b-62ea-4a81-a007-965aa5abf445" data-section-level="2" data-section-text="Jacobian Definition"><h2 id="jacobian_definition">Jacobian Definition</h2><p>An efficient Newton solve, e.g. one that requires few &quot;non-linear&quot; iterations, requires an accurate Jacobian matrix or an accurate approximation of its action on a vector. When no explicit matrix is formed for the Jacobian and only its action on a vector is computed, the algorithm is commonly referred to as matrix-free (PETSc jargon) or <a href="NonlinearSystem.html#JFNK">Jacobian-free</a> (MOOSE jargon). The default solve algorithm in MOOSE is <code>PJFNK</code>, or Preconditioned Jacobian-Free Newton-Krylov. &quot;Krylov&quot; refers to the <em>linear</em> solution algorithm used to solve each non-linear iteration of the Newton algorithm. For more information on solving linear systems, please see <a href="NonlinearSystem.html#linear_methods">Solving Linear Systems</a>. Even if a Jacobian-free non-linear algorithm is chosen, typically a good preconditioning matrix is still needed. Building the matrix can be accomplished <a href="NonlinearSystem.html#AD">automatically, using automatic differentiation</a> and/or <a href="NonlinearSystem.html#hand_coded_jac">manually</a>.</p><section id="27f2c308-0b08-431f-94d3-835ced0329db" data-section-level="3" data-section-text="Automatic Differentiation"><h3 id="AD">Automatic Differentiation</h3><p>One can elect to sacrifice some computing speed and calculate Jacobians automatically using <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation (AD)</a>. MOOSE employs the <code>DualNumber</code> class from the <a href="https://github.com/roystgnr/MetaPhysicL">MetaPhysicL</a> package in order to enable AD. If the application developer wants to make use of AD, they should inherit from <code>ADKernel</code> as opposed to <code>Kernel</code>. Additionally, when coupling in variables, the <code>adCoupled*</code> methods should be used. For example, to retrieve a coupled value, instead of using <code>coupledValue(&quot;v&quot;)</code> in the <code>ADKernel</code> constructor, <code>adCoupledValue(&quot;v&quot;)</code> should be used. <code>adCoupledGradient</code> should replace <code>coupledGradient</code>, etc. An example of coupling in an AD variable can be found in <a class="moose-source-filename tooltipped modal-trigger" href="#2dca7c1e-d70b-4af6-afe8-01cfda18672b"><code>ADCoupledConvection.C</code></a> and <a class="moose-source-filename tooltipped modal-trigger" href="#830530f7-3e07-40ba-855f-7f8f26a44f8f"><code>ADCoupledConvection.h</code></a>. Moreover, material properties that may depend on the non-linear variables should be retrieved using <code>getADMaterialProperty</code> instead of <code>getMaterialProperty</code>. They should be declared in materials using <code>declareADProperty</code>. Example AD material source and header files can be found <a class="moose-source-filename tooltipped modal-trigger" href="#a4cd9fec-60ea-47d6-ac9e-36ff3e3e8a41">here</a> and <a class="moose-source-filename tooltipped modal-trigger" href="#193ca8c1-9689-45d2-95bc-3d033b9fbcae">here</a>; example kernel source and header files that use AD material properties can be found <a class="moose-source-filename tooltipped modal-trigger" href="#a9d2ead7-f928-47aa-9ffa-8ce41c184c7a">here</a> and <a class="moose-source-filename tooltipped modal-trigger" href="#15886f17-e2c2-4356-a27c-f8dda004d4b2">here</a>. The object central to AD computing objects is <code>ADReal</code> which is defined in <a href="../utils/MooseTypes.html"><code>MooseTypes</code></a>.</p></section><section id="5bd5697a-edb3-4d5f-b2c6-4bee5e043130" data-section-level="3" data-section-text="Traditional Hand - coded Jacobians"><h3 id="hand_coded_jac">Traditional Hand-coded Jacobians</h3><p>Finite element shape functions are introduced in the documentation section <a href="../problems/FEProblemBase.html#shape_functions">Shape Functions</a>. There we outline how our primary variables are summations of those shape functions multiplied by constant coefficients which are our degrees of freedom. At the end of <a href="NonlinearSystem.html#newtons_method">Solving Non-linear Systems</a> we gave an explicit illustration of how the derivative of a variable <code>u</code> with respect to its jth degree of freedom (<span class="moose-katex-inline-equation" id="moose-equation-479750c6-8b52-44ae-bbac-e8465329f1e2"><script>var element = document.getElementById("moose-equation-479750c6-8b52-44ae-bbac-e8465329f1e2");katex.render("u_j", element, {displayMode:false,throwOnError:false});</script></span>) is equal to the jth shape function <span class="moose-katex-inline-equation" id="moose-equation-2b172006-5e67-40ba-ba11-24638a365232"><script>var element = document.getElementById("moose-equation-2b172006-5e67-40ba-ba11-24638a365232");katex.render("\\phi_j", element, {displayMode:false,throwOnError:false});</script></span>. Similarly the derivative of <span class="moose-katex-inline-equation" id="moose-equation-f0f9d905-12f2-48d1-9e89-da7bd79e2089"><script>var element = document.getElementById("moose-equation-f0f9d905-12f2-48d1-9e89-da7bd79e2089");katex.render("\\nabla u", element, {displayMode:false,throwOnError:false});</script></span> with respect to <span class="moose-katex-inline-equation" id="moose-equation-1f2a308a-aba7-4677-a6fd-ec9d610a8240"><script>var element = document.getElementById("moose-equation-1f2a308a-aba7-4677-a6fd-ec9d610a8240");katex.render("u_j", element, {displayMode:false,throwOnError:false});</script></span> is equal to <span class="moose-katex-inline-equation" id="moose-equation-cd53644f-ade0-421f-9591-5ab8dce420fe"><script>var element = document.getElementById("moose-equation-cd53644f-ade0-421f-9591-5ab8dce420fe");katex.render("\\nabla \\phi_j", element, {displayMode:false,throwOnError:false});</script></span>. The code expression  <code>_phi[_j][_qp]</code> represents <span class="moose-katex-inline-equation" id="moose-equation-cc8d8e36-3dc2-476f-a6de-fc208b46bba7"><script>var element = document.getElementById("moose-equation-cc8d8e36-3dc2-476f-a6de-fc208b46bba7");katex.render("\\frac{\\partial u}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> in any MOOSE framework residual and Jacobian computing objects such as kernels and boundary conditions.</p><p>Any MOOSE kernel may have an arbitrary number of variables coupled into it. If these coupled variables use the same shape function family and order, then their associated <span class="moose-katex-inline-equation" id="moose-equation-e2d35456-d0fb-43c0-b06c-5353656332d9"><script>var element = document.getElementById("moose-equation-e2d35456-d0fb-43c0-b06c-5353656332d9");katex.render("\\phi_j", element, {displayMode:false,throwOnError:false});</script></span>s will be equivalent. However, if <code>u</code> and <code>v</code> use different shape functions then <span class="moose-katex-inline-equation" id="moose-equation-7c3972ca-4170-4c71-a830-00ff180a4d28"><script>var element = document.getElementById("moose-equation-7c3972ca-4170-4c71-a830-00ff180a4d28");katex.render("\\phi_{j,u} \\ne \\phi_{j,v}", element, {displayMode:false,throwOnError:false});</script></span>. As a developer, however, you do not <em></em><em>in most cases</em><em></em> have to worry about these differences in <span class="moose-katex-inline-equation" id="moose-equation-a874f218-c91e-4313-873f-d2c5e238e976"><script>var element = document.getElementById("moose-equation-a874f218-c91e-4313-873f-d2c5e238e976");katex.render("\\phi", element, {displayMode:false,throwOnError:false});</script></span>. MOOSE automatically updates the object member variable <code>_phi</code> to use the shape functions of the variable for whom the Jacobian is currently being computed. <em></em><em>However</em><em></em>, if the primary variable <code>u</code> is a scalar-valued (single-component) finite element variable and the coupled variable <code>v</code> is a vector-valued (multi-component) finite element variable (or visa versa), then you must introduce an additional member variable to represent the shape functions of the vector-valued (scalar-valued) variable. The name of this variable is up to the developer, but we suggest perhaps a <code>_standard_</code> prefix for scalar valued finite-element variables and <code>_vector_</code> for vector valued finite-element variables. The <code>_standard_</code> prefix is suggested over <code>_scalar_</code> so as not to be confused with a <code>MooseVariableScalar</code>, which only has a single value over the entire spatial domain. An example constructor for a standard kernel that couples in a vector-valued FE variable is shown below:</p><pre class="moose-pre"><code class="language-text">
EFieldAdvection::EFieldAdvection(const InputParameters &amp; parameters)
  : Kernel(parameters),
    _efield_id(coupled(&quot;efield&quot;)),
    _efield(coupledVectorValue(&quot;efield&quot;)),
    _efield_var(*getVectorVar(&quot;efield&quot;, 0)),
    _vector_phi(_assembly.phi(_efield_var)),
    _mobility(getParam&lt;Real&gt;(&quot;mobility&quot;))
{
}
</code></pre><p>The associated declarations are:</p><pre class="moose-pre"><code class="language-text">
  const unsigned int _efield_id;
  const VectorVariableValue &amp; _efield;
  VectorMooseVariable &amp; _efield_var;
  const VectorVariablePhiValue &amp; _vector_phi;
  const Real _mobility;
  Real _sgn;
</code></pre><p>Residual, on-diagonal, and off-diagonal methods are respectively</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpResidual()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _u[_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpJacobian()
{
  return -_grad_test[_i][_qp] * _sgn * _mobility * _efield[_qp] * _phi[_j][_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
EFieldAdvection::computeQpOffDiagJacobian(unsigned int jvar)
{
  if (jvar == _efield_id)
    return -_grad_test[_i][_qp] * _sgn * _mobility * _vector_phi[_j][_qp] * _u[_qp];
  else
    return 0;
}

```
An example constructor for a vector kernel that couples in a
scalar-valued FE variable is shown below:

```
VectorCoupledGradientTimeDerivative::VectorCoupledGradientTimeDerivative(
    const InputParameters &amp; parameters)
  : VectorKernel(parameters),
    _grad_v_dot(coupledGradientDot(&quot;v&quot;)),
    _d_grad_v_dot_dv(coupledDotDu(&quot;v&quot;)),
    _v_id(coupled(&quot;v&quot;)),
    _v_var(*getVar(&quot;v&quot;, 0)),
    _standard_grad_phi(_assembly.gradPhi(_v_var))
{
}

```
The associated declarations are:

```
  const VariableGradient &amp; _grad_v_dot;
  const VariableValue &amp; _d_grad_v_dot_dv;
  const unsigned _v_id;
  MooseVariable &amp; _v_var;
  const VariablePhiGradient &amp; _standard_grad_phi;
</code></pre><p>Residual and off-diagonal Jacobian methods are respectively:</p><pre class="moose-pre"><code class="language-text">
Real
VectorCoupledGradientTimeDerivative::computeQpResidual()
{
  return _test[_i][_qp] * _grad_v_dot[_qp];
}
</code></pre><p>and</p><pre class="moose-pre"><code class="language-text">
Real
VectorCoupledGradientTimeDerivative::computeQpOffDiagJacobian(unsigned jvar)
{
  if (jvar == _v_id)
    return _test[_i][_qp] * _d_grad_v_dot_dv[_qp] * _standard_grad_phi[_j][_qp];

  else
    return 0.;
}
</code></pre><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Flexibility</div><div class="card-content"><div class="moose-alert-content"><p><p>Note that only one member is needed to represent shape functions for standard     <code>MooseVariable</code>s and <code>VectorMooseVariable</code>s. For example, if the vector-variables     <code>v</code> and <code>w</code> are coupled into a standard kernel for <code>u</code>, only a single     <code>_vector_phi</code> member needs to be added; there is not need for both a     <code>_v_phi</code> and <code>_w_phi</code>. <code>_vector_phi</code> will be automatically updated to     represent the shape functions for whichever vector variable the Jacobian is     being computed for.</p></p></div></div></div></section><section id="007402fd-6796-46c0-bd1e-c1cea0abf44d" data-section-level="3" data-section-text="Newton for a Simple Equation"><h3 id="simple_newton">Newton for a Simple Equation</h3><ul class="browser-default"><li><p>Consider the convection-diffusion equation with nonlinear <span class="moose-katex-inline-equation" id="moose-equation-8fa1a2eb-3e1e-4800-96d5-fb1c38c6d184"><script>var element = document.getElementById("moose-equation-8fa1a2eb-3e1e-4800-96d5-fb1c38c6d184");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-4b1b4356-fadc-40dc-82d8-5d8c302d0ec8"><script>var element = document.getElementById("moose-equation-4b1b4356-fadc-40dc-82d8-5d8c302d0ec8");katex.render("\\vec{\\beta}", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-a97b6d37-ec2d-4661-81aa-a403a9e69eb7"><script>var element = document.getElementById("moose-equation-a97b6d37-ec2d-4661-81aa-a403a9e69eb7");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>:   <span class="moose-katex-inline-equation" id="moose-equation-5636a5bd-b0d3-4fb7-9ac2-6d95a34af009"><script>var element = document.getElementById("moose-equation-5636a5bd-b0d3-4fb7-9ac2-6d95a34af009");katex.render("\\begin{aligned}- \\nabla\\cdot k\\nabla u + \\vec{\\beta} \\cdot \\nabla u = f\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>The <span class="moose-katex-inline-equation" id="moose-equation-aaa09bd9-d11f-412d-8910-7e5070e2d685"><script>var element = document.getElementById("moose-equation-aaa09bd9-d11f-412d-8910-7e5070e2d685");katex.render("i^{th}", element, {displayMode:false,throwOnError:false});</script></span> component of the residual vector is:   <span class="moose-katex-inline-equation" id="moose-equation-65b2633e-1a9c-4f8f-855b-8b1deb0b00b6"><script>var element = document.getElementById("moose-equation-65b2633e-1a9c-4f8f-855b-8b1deb0b00b6");katex.render("\\begin{aligned}   R_i(u_h) = \\left(\\nabla\\psi_i, k\\nabla u_h \\right) - \\langle\\psi_i, k\\nabla u_h\\cdot \\hat{n} \\rangle +   \\left(\\psi_i, \\vec{\\beta} \\cdot \\nabla u_h\\right) - \\left(\\psi_i, f\\right)\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul><ul class="browser-default"><li><p>Using the previously-defined rules for <span class="moose-katex-inline-equation" id="moose-equation-5a5c7ce0-e261-4f7b-a980-f10a297b5aa3"><script>var element = document.getElementById("moose-equation-5a5c7ce0-e261-4f7b-a980-f10a297b5aa3");katex.render("\\frac{\\partial u_h}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-63160618-f17d-45c6-99d7-0b4dee3ac98c"><script>var element = document.getElementById("moose-equation-63160618-f17d-45c6-99d7-0b4dee3ac98c");katex.render("\\frac{\\partial \\left(\\nabla u_h\\right)}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span>, the <span class="moose-katex-inline-equation" id="moose-equation-04bf914d-7df4-4179-8cff-7bce56e1a312"><script>var element = document.getElementById("moose-equation-04bf914d-7df4-4179-8cff-7bce56e1a312");katex.render("(i,j)", element, {displayMode:false,throwOnError:false});</script></span> entry of the Jacobian is then:</p></li></ul><p><span class="moose-katex-inline-equation" id="moose-equation-7a86e740-5425-4b24-b37b-6c4fa8e442b3"><script>var element = document.getElementById("moose-equation-7a86e740-5425-4b24-b37b-6c4fa8e442b3");katex.render("\\begin{aligned} J_{ij}(u_h) &= \\left(\\nabla\\psi_i, \\frac{\\partial k}{\\partial u_j}\\nabla u_h \\right) + \\left(\\nabla\\psi_i, k \\nabla \\phi_j \\right) - \\left \\langle\\psi_i, \\frac{\\partial k}{\\partial u_j}\\nabla u_h\\cdot \\hat{n} \\right\\rangle \\\\&- \\left \\langle\\psi_i, k\\nabla \\phi_j\\cdot \\hat{n} \\right\\rangle + \\left(\\psi_i, \\frac{\\partial \\vec{\\beta}}{\\partial u_j} \\cdot\\nabla u_h\\right) + \\left(\\psi_i, \\vec{\\beta} \\cdot \\nabla \\phi_j\\right) - \\left(\\psi_i, \\frac{\\partial f}{\\partial u_j}\\right)\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><ul class="browser-default"><li><p>Note that even for this &quot;simple&quot; equation, the Jacobian entries are nontrivial: they depend on the partial derivatives of <span class="moose-katex-inline-equation" id="moose-equation-073037bd-82a3-479b-b29c-1dc07e5bbc10"><script>var element = document.getElementById("moose-equation-073037bd-82a3-479b-b29c-1dc07e5bbc10");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-c844fa9d-c0c4-4bbc-afdd-da284fc24d27"><script>var element = document.getElementById("moose-equation-c844fa9d-c0c4-4bbc-afdd-da284fc24d27");katex.render("\\vec{\\beta}", element, {displayMode:false,throwOnError:false});</script></span>, and <span class="moose-katex-inline-equation" id="moose-equation-eae9c1c5-15fb-4849-8192-ca35dc2335ab"><script>var element = document.getElementById("moose-equation-eae9c1c5-15fb-4849-8192-ca35dc2335ab");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>, which may be difficult or time-consuming to compute analytically.</p><p></p></li><li><p>In a multiphysics setting with many coupled equations and complicated material properties, the Jacobian might be extremely difficult to determine.</p></li></ul></section><section id="40b5ed51-2e8d-463d-befb-779adb434433" data-section-level="3" data-section-text="Chain Rule"><h3 id="chain_rule">Chain Rule</h3><ul class="browser-default"><li><p>On the previous slide, the term <span class="moose-katex-inline-equation" id="moose-equation-7e56326d-5572-4442-a344-7d63a5ab508d"><script>var element = document.getElementById("moose-equation-7e56326d-5572-4442-a344-7d63a5ab508d");katex.render("\\frac{\\partial f}{\\partial u_j}", element, {displayMode:false,throwOnError:false});</script></span> was used, where <span class="moose-katex-inline-equation" id="moose-equation-f4e95703-3295-43fc-b96a-9313d6968f34"><script>var element = document.getElementById("moose-equation-f4e95703-3295-43fc-b96a-9313d6968f34");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> was a nonlinear forcing function.</p><p></p></li><li><p>The chain rule allows us to write this term as</p><p><span class="moose-katex-inline-equation" id="moose-equation-f7d4aee9-dca5-4cd1-a1f2-ccbb90045d29"><script>var element = document.getElementById("moose-equation-f7d4aee9-dca5-4cd1-a1f2-ccbb90045d29");katex.render("\\begin{aligned}   \\frac{\\partial f}{\\partial u_j} &= \\frac{\\partial f}{\\partial u_h} \\frac{\\partial u_h}{\\partial u_j}   \\\\   &=\\frac{\\partial f}{\\partial u_h} \\phi_j\\end{aligned}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>If a functional form of <span class="moose-katex-inline-equation" id="moose-equation-d845e2c7-e0de-493c-8cd8-f7466bbe3a6f"><script>var element = document.getElementById("moose-equation-d845e2c7-e0de-493c-8cd8-f7466bbe3a6f");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> is known, e.g. <span class="moose-katex-inline-equation" id="moose-equation-b54e3fe4-335e-4b95-89ff-40e7c919029b"><script>var element = document.getElementById("moose-equation-b54e3fe4-335e-4b95-89ff-40e7c919029b");katex.render("f(u) = \\sin(u)", element, {displayMode:false,throwOnError:false});</script></span>, this formula implies that its Jacobian contribution is given by</p><p> <span class="moose-katex-inline-equation" id="moose-equation-3fd5ae9a-6218-4b46-a22c-5d332fcea991"><script>var element = document.getElementById("moose-equation-3fd5ae9a-6218-4b46-a22c-5d332fcea991");katex.render("\\frac{\\partial f}{\\partial u_j} = \\cos(u_h) \\phi_j", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section><section id="b7f74f12-41f9-4f9e-9313-162265d4e409" data-section-level="3" data-section-text="Jacobian - Free Newton - Krylov"><h3 id="JFNK">Jacobian-Free Newton-Krylov</h3><ul class="browser-default"><li><p><span class="moose-katex-inline-equation" id="moose-equation-546c1b49-5abb-4617-bf78-9f66bb9876ea"><script>var element = document.getElementById("moose-equation-546c1b49-5abb-4617-bf78-9f66bb9876ea");katex.render("\\mathbf{J}(\\vec{u}_n)\\delta \\vec{u}_{n+1} = -\\vec{R}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> is a linear system solved during each Newton step. </p></li><li><p>For simplicity, we can write this linear system as <span class="moose-katex-inline-equation" id="moose-equation-e2b81516-b098-43f8-b0dc-39ce4ffae259"><script>var element = document.getElementById("moose-equation-e2b81516-b098-43f8-b0dc-39ce4ffae259");katex.render("\\mathbf{A}\\vec{x} = \\vec{b}", element, {displayMode:false,throwOnError:false});</script></span>, where:   - <span class="moose-katex-inline-equation" id="moose-equation-4043d5bd-0d4a-4803-8676-fd188cd4f39c"><script>var element = document.getElementById("moose-equation-4043d5bd-0d4a-4803-8676-fd188cd4f39c");katex.render("\\mathbf{A} \\equiv \\mathbf{J}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span>   - <span class="moose-katex-inline-equation" id="moose-equation-386f199a-5015-4199-bdec-d8114db5470b"><script>var element = document.getElementById("moose-equation-386f199a-5015-4199-bdec-d8114db5470b");katex.render("\\vec{x} \\equiv \\delta \\vec{u}_{n+1}", element, {displayMode:false,throwOnError:false});</script></span>   - <span class="moose-katex-inline-equation" id="moose-equation-ccd06d02-a003-4e8f-81f7-7278fe1b2d79"><script>var element = document.getElementById("moose-equation-ccd06d02-a003-4e8f-81f7-7278fe1b2d79");katex.render("\\vec{b} \\equiv -\\vec{R}(\\vec{u}_n)", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p>We employ an iterative Krylov method (e.g. GMRES) to produce a sequence of iterates <span class="moose-katex-inline-equation" id="moose-equation-6f310f83-5d96-4b52-9e10-38bdd020f80f"><script>var element = document.getElementById("moose-equation-6f310f83-5d96-4b52-9e10-38bdd020f80f");katex.render("\\vec{x}_k \\rightarrow \\vec{x}", element, {displayMode:false,throwOnError:false});</script></span>, <span class="moose-katex-inline-equation" id="moose-equation-2e2517fa-cf6a-4aa8-a865-437a15a09440"><script>var element = document.getElementById("moose-equation-2e2517fa-cf6a-4aa8-a865-437a15a09440");katex.render("k=1,2,\\ldots", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><span class="moose-katex-inline-equation" id="moose-equation-eec92c38-a90c-4c5e-aa02-88e16ed803ac"><script>var element = document.getElementById("moose-equation-eec92c38-a90c-4c5e-aa02-88e16ed803ac");katex.render("\\mathbf{A}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-eeb5fc74-0344-40db-98b3-afd272d7792b"><script>var element = document.getElementById("moose-equation-eeb5fc74-0344-40db-98b3-afd272d7792b");katex.render("\\vec{b}", element, {displayMode:false,throwOnError:false});</script></span> remain <em>fixed</em> during the iterative process. </p></li><li><p>The &quot;linear residual&quot; at step <span class="moose-katex-inline-equation" id="moose-equation-d3174311-c3f5-44de-89e0-46eef061dc5f"><script>var element = document.getElementById("moose-equation-d3174311-c3f5-44de-89e0-46eef061dc5f");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span> is defined as</p><p><span class="moose-katex-inline-equation" id="moose-equation-8a97312f-e1f7-4aa5-96fa-57805b7216cd"><script>var element = document.getElementById("moose-equation-8a97312f-e1f7-4aa5-96fa-57805b7216cd");katex.render("\\vec{\\rho}_k \\equiv \\mathbf{A}\\vec{x}_k - \\vec{b}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>MOOSE prints the norm of this vector, <span class="moose-katex-inline-equation" id="moose-equation-2adf99c4-ed75-4be3-a26b-b424bbf6f189"><script>var element = document.getElementById("moose-equation-2adf99c4-ed75-4be3-a26b-b424bbf6f189");katex.render("\\|\\vec{\\rho}_k\\|", element, {displayMode:false,throwOnError:false});</script></span>, at each iteration, if you set <code>print_linear_residuals = true</code> in the <code>Outputs</code> block.</p><p></p></li><li><p>The &quot;nonlinear residual&quot; printed by MOOSE is <span class="moose-katex-inline-equation" id="moose-equation-66ce2d32-c3f4-47f0-96df-df38ec427e3a"><script>var element = document.getElementById("moose-equation-66ce2d32-c3f4-47f0-96df-df38ec427e3a");katex.render("\\|\\vec{R}(\\vec{u}_n)\\|", element, {displayMode:false,throwOnError:false});</script></span>.</p><p></p></li><li><p>By iterate <span class="moose-katex-inline-equation" id="moose-equation-19299ad7-1588-46ef-bcaa-0206c7736b02"><script>var element = document.getElementById("moose-equation-19299ad7-1588-46ef-bcaa-0206c7736b02");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span>, the Krylov method has constructed the subspace</p><p><span class="moose-katex-inline-equation" id="moose-equation-f684e975-5a72-4da7-bf3a-2dc90a282792"><script>var element = document.getElementById("moose-equation-f684e975-5a72-4da7-bf3a-2dc90a282792");katex.render("\\mathcal{K}_k = \\text{span}\\{ \\vec{b}, \\mathbf{A}\\vec{b}, \\mathbf{A}^2\\vec{b}, \\ldots, \\mathbf{A}^{k-1}\\vec{b}\\}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>Different Krylov methods produce the <span class="moose-katex-inline-equation" id="moose-equation-04ce0ee5-e6fd-455e-b8b9-8321107b5b55"><script>var element = document.getElementById("moose-equation-04ce0ee5-e6fd-455e-b8b9-8321107b5b55");katex.render("\\vec{x}_k", element, {displayMode:false,throwOnError:false});</script></span> iterates in different ways: </p></li><li><p>Conjugate Gradients: <span class="moose-katex-inline-equation" id="moose-equation-3e2a116b-5edc-40c5-abfb-53bf26b3971d"><script>var element = document.getElementById("moose-equation-3e2a116b-5edc-40c5-abfb-53bf26b3971d");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> orthogonal to <span class="moose-katex-inline-equation" id="moose-equation-b700f51c-6f53-48cf-80d8-5985f0a52a54"><script>var element = document.getElementById("moose-equation-b700f51c-6f53-48cf-80d8-5985f0a52a54");katex.render("\\mathcal{K}_k", element, {displayMode:false,throwOnError:false});</script></span>. </p></li><li><p>GMRES/MINRES: <span class="moose-katex-inline-equation" id="moose-equation-725af68e-24f5-4b39-992a-de9ed3db0628"><script>var element = document.getElementById("moose-equation-725af68e-24f5-4b39-992a-de9ed3db0628");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> has minimum norm for <span class="moose-katex-inline-equation" id="moose-equation-2656eb7f-51e5-4a6e-83c3-8e672e72b022"><script>var element = document.getElementById("moose-equation-2656eb7f-51e5-4a6e-83c3-8e672e72b022");katex.render("\\vec{x}_k", element, {displayMode:false,throwOnError:false});</script></span> in <span class="moose-katex-inline-equation" id="moose-equation-1501525b-5a46-4e5e-95ea-f27c515230da"><script>var element = document.getElementById("moose-equation-1501525b-5a46-4e5e-95ea-f27c515230da");katex.render("\\mathcal{K}_k", element, {displayMode:false,throwOnError:false});</script></span>. </p></li><li><p>Biconjugate Gradients: <span class="moose-katex-inline-equation" id="moose-equation-9fe70e24-54e9-4279-80d4-a1344d9b18b5"><script>var element = document.getElementById("moose-equation-9fe70e24-54e9-4279-80d4-a1344d9b18b5");katex.render("\\vec{\\rho}_k", element, {displayMode:false,throwOnError:false});</script></span> is orthogonal to <span class="moose-katex-inline-equation" id="moose-equation-90172fdb-c188-41ee-8322-e9c636b8110d"><script>var element = document.getElementById("moose-equation-90172fdb-c188-41ee-8322-e9c636b8110d");katex.render("\\mathcal{K}_k(\\mathbf{A}^T)", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p><span class="moose-katex-inline-equation" id="moose-equation-d913112d-a177-43bf-a6aa-c62ea6581167"><script>var element = document.getElementById("moose-equation-d913112d-a177-43bf-a6aa-c62ea6581167");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> is never explicitly needed to construct the subspace, only the action of <span class="moose-katex-inline-equation" id="moose-equation-a2976d30-b485-47a5-a59d-1166a405e735"><script>var element = document.getElementById("moose-equation-a2976d30-b485-47a5-a59d-1166a405e735");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> on a vector is required.</p></li></ul><ul class="browser-default"><li><p>This action can be approximated by:   <span class="moose-katex-inline-equation" id="moose-equation-b442fbe6-ab68-4bf4-ac1a-e14ee1836cf6"><script>var element = document.getElementById("moose-equation-b442fbe6-ab68-4bf4-ac1a-e14ee1836cf6");katex.render("\\mathbf{J}\\vec{v} \\approx \\frac{\\vec{R}(\\vec{u} + \\epsilon\\vec{v}) - \\vec{R}(\\vec{u})}{\\epsilon}", element, {displayMode:false,throwOnError:false});</script></span></p><p></p></li><li><p>This form has many advantages:   - No need to do analytic derivatives to form <span class="moose-katex-inline-equation" id="moose-equation-b6dd2f00-f649-421b-b25b-a710dd2e6d68"><script>var element = document.getElementById("moose-equation-b6dd2f00-f649-421b-b25b-a710dd2e6d68");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span>   - No time needed to compute <span class="moose-katex-inline-equation" id="moose-equation-2c308933-fd5a-40e0-ad3a-8bb454c4c9c5"><script>var element = document.getElementById("moose-equation-2c308933-fd5a-40e0-ad3a-8bb454c4c9c5");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span> (just residual computations)   - No space needed to store <span class="moose-katex-inline-equation" id="moose-equation-e686ebc5-de94-48cb-a862-a3d404683376"><script>var element = document.getElementById("moose-equation-e686ebc5-de94-48cb-a862-a3d404683376");katex.render("\\mathbf{J}", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section></section><section class="scrollspy" id="aa449cde-a8ae-4481-b45d-af9eaaef13d1" data-section-level="2" data-section-text="Solving Linear Systems"><h2 id="linear_methods">Solving Linear Systems</h2><p>You will commonly hear of two ways to solve an implicit linear system of equations: directly or iteratively. A typical direct solve will perform a <a href="https://en.wikipedia.org/wiki/LU_decomposition">LU factorization</a>. Direct solves are a great tool for solving small-medium sized systems; however, they are extremely expensive when applied to large-scale problems. To solve large-scale systems, iterative methods must be used. The most successful iterative methods are Krylov methods. Krylov methods are work by finding a solution to <span class="moose-katex-inline-equation" id="moose-equation-307614b2-d710-411e-b4f5-3bc7f0a4ad24"><script>var element = document.getElementById("moose-equation-307614b2-d710-411e-b4f5-3bc7f0a4ad24");katex.render("Ax=b", element, {displayMode:false,throwOnError:false});</script></span> within a space called the <a href="https://en.wikipedia.org/wiki/Krylov_subspace">Krylov sub-space</a> which is spanned by images of <span class="moose-katex-inline-equation" id="moose-equation-66efaf0f-4191-4643-8b3e-fbc156609b14"><script>var element = document.getElementById("moose-equation-66efaf0f-4191-4643-8b3e-fbc156609b14");katex.render("b", element, {displayMode:false,throwOnError:false});</script></span> under powers of <span class="moose-katex-inline-equation" id="moose-equation-2a7748da-4700-46f2-a922-2faf4ae39f65"><script>var element = document.getElementById("moose-equation-2a7748da-4700-46f2-a922-2faf4ae39f65");katex.render("A", element, {displayMode:false,throwOnError:false});</script></span>. Two of the most used Krylov algorithms are <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">Conjugate gradient</a> and <a href="https://en.wikipedia.org/wiki/GMRES">GMRES</a>. Conjugate gradient generally only works for symmetric positive-definite matrices. Because of its greater flexibility, GMRES is the default linear solution algorithm in PETSc and consequently for MOOSE.</p></section><section class="scrollspy" id="cbbc40bb-24d6-4ff0-838a-ac29db93953e" data-section-level="2" data-section-text="Augmenting Sparsity"><h2 id="augmenting_sparsity">Augmenting Sparsity</h2><p>One such routine is <code>NonlinearSystemBase::augmentSparsity</code>, which as its name suggests augments the sparsity pattern of the matrix. Currently this method adds sparsity coming from MOOSE <code>Constraint</code> objects. It does this by querying geometric connectivity information between secondary and primary boundary pairs, and then querying the <code>DofMap</code> attached to the <code>NonlinearSystemBase</code> (through the libMesh <code>NonlinearImplicitSystem</code>) for the dof indices that exist on the elements attached to the secondary/primary nodes. The geometric connectivity information comes from <a href="../geomsearch/NearestNodeLocator.html"><code>NearestNodeLocators</code></a> held by <a href="../geomsearch/GeometricSearchData.html"><code>GeometricSearchData</code></a> objects in the <a href="../problems/FEProblemBase.html"><code>FEProblemBase</code></a> and <a href="../problems/DisplacedProblem.html"><code>DisplacedProblem</code></a> (the latter only if there are mesh displacements). In the future sparsity augmentation from constraints will occur through <a href="../relationshipmanagers/RelationshipManager.html"><code>RelationshipManagers</code></a> instead of through the <code>augmentSparsity</code> method. </p></section></section><div class="moose-modal modal" id="2dca7c1e-d70b-4af6-afe8-01cfda18672b"><div class="modal-content"><h4>(doc/test/src/kernels/ADCoupledConvection.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledConvection.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledConvection);

InputParameters
ADCoupledConvection::validParams()
{
  InputParameters params = ADKernel::validParams();
  params.addParam&lt;Real&gt;(&quot;scale&quot;, 1, &quot;Scaling coefficient&quot;);
  params.addRequiredCoupledVar(&quot;velocity_vector&quot;, &quot;Velocity Vector for the Convection ADKernel&quot;);
  return params;
}

ADCoupledConvection::ADCoupledConvection(const InputParameters &amp; parameters)
  : ADKernel(parameters),
    _velocity_vector(adCoupledGradient(&quot;velocity_vector&quot;)),
    _scale(getParam&lt;Real&gt;(&quot;scale&quot;))
{
}

ADReal
ADCoupledConvection::computeQpResidual()
{
  return _scale * _test[_i][_qp] * _velocity_vector[_qp] * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="830530f7-3e07-40ba-855f-7f8f26a44f8f"><div class="modal-content"><h4>(doc/test/include/kernels/ADCoupledConvection.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;ADKernel.h&quot;

/**
 * Define the ADKernel for a convection operator that looks like:
 *
 * grad_some_var dot u&#x27;
 */
class ADCoupledConvection : public ADKernel
{
public:
  static InputParameters validParams();

  ADCoupledConvection(const InputParameters &amp; parameters);

protected:
  virtual ADReal computeQpResidual() override;


private:
  const ADVariableGradient &amp; _velocity_vector;

  const Real &amp; _scale;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a4cd9fec-60ea-47d6-ac9e-36ff3e3e8a41"><div class="modal-content"><h4>(doc/test/src/materials/ADCoupledMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledMaterial);

InputParameters
ADCoupledMaterial::validParams()
{
  InputParameters params = ADMaterial::validParams();
  params.addRequiredCoupledVar(&quot;coupled_var&quot;, &quot;A coupledvariable&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;ad_mat_prop&quot;,
                                                &quot;Name of the ad property this material defines&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(
      &quot;regular_mat_prop&quot;, &quot;Name of the regular property this material defines&quot;);
  return params;
}

ADCoupledMaterial::ADCoupledMaterial(const InputParameters &amp; parameters)
  : ADMaterial(parameters),
    _ad_mat_prop(declareADProperty&lt;Real&gt;(getParam&lt;MaterialPropertyName&gt;(&quot;ad_mat_prop&quot;))),
    _regular_mat_prop(declareProperty&lt;Real&gt;(getParam&lt;MaterialPropertyName&gt;(&quot;regular_mat_prop&quot;))),
    _coupled_var(adCoupledValue(&quot;coupled_var&quot;))
{
}

// Note that the structure of the two (uncommented) methods below are for testing purposes only;
// e.g. this material demonstrates that you get bad convergence when you drop the derivative
// information from the coupled variable. A production version of this material would look like
// this:
//
// // void
// ADCoupledMaterial::computeQpProperties()
// {
//   _ad_mat_prop[_qp] = 4.0 * _coupled_var[_qp];
// }

void
ADCoupledMaterial::computeQpProperties()
{
  _regular_mat_prop[_qp] = 4.0 * MetaPhysicL::raw_value(_coupled_var[_qp]);
  _ad_mat_prop[_qp] = 4.0 * _coupled_var[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="193ca8c1-9689-45d2-95bc-3d033b9fbcae"><div class="modal-content"><h4>(doc/test/include/materials/ADCoupledMaterial.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;ADMaterial.h&quot;

/**
 * A material that couples a material property
 */
class ADCoupledMaterial : public ADMaterial
{
public:
  static InputParameters validParams();

  ADCoupledMaterial(const InputParameters &amp; parameters);

protected:
  virtual void computeQpProperties();

  ADMaterialProperty&lt;Real&gt; &amp; _ad_mat_prop;
  MaterialProperty&lt;Real&gt; &amp; _regular_mat_prop;

  const ADVariableValue &amp; _coupled_var;

};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a9d2ead7-f928-47aa-9ffa-8ce41c184c7a"><div class="modal-content"><h4>(doc/test/src/kernels/ADMatDiffusionTest.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADMatDiffusionTest.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADMatDiffusionTest);

InputParameters
ADMatDiffusionTest::validParams()
{
  InputParameters params = ADKernel::validParams();
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;ad_mat_prop&quot;, &quot;ad_diffusivity&quot;, &quot;the name of the AD material property we are going to use&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(&quot;regular_mat_prop&quot;,
                                        &quot;regular_diffusivity&quot;,
                                        &quot;the name of the AD material property we are going to use&quot;);
  MooseEnum prop_to_use(&quot;AdAd  RegReg&quot;, &quot;AdAd&quot;);
  params.addParam&lt;MooseEnum&gt;(&quot;prop_to_use&quot;,
                             prop_to_use,
                             &quot;What type of property to use. The prefix indicates the getter type &quot;
                             &quot;in the kernel; the suffix indicates the declaration type in the &quot;
                             &quot;material.&quot;);
  return params;
}

ADMatDiffusionTest::ADMatDiffusionTest(const InputParameters &amp; parameters)
  : ADKernel(parameters),
    _ad_diff_from_ad_prop(getADMaterialProperty&lt;Real&gt;(&quot;ad_mat_prop&quot;)),
    _regular_diff_from_regular_prop(getMaterialProperty&lt;Real&gt;(&quot;regular_mat_prop&quot;)),
    _prop_to_use(getParam&lt;MooseEnum&gt;(&quot;prop_to_use&quot;))
{
  // check whether our has APIs work

  if (!hasADMaterialProperty&lt;Real&gt;(&quot;ad_mat_prop&quot;) &amp;&amp;
      !defaultADMaterialProperty&lt;Real&gt;(deducePropertyName(&quot;ad_mat_prop&quot;)))
    mooseError(&quot;It should be impossible to get an AD property without erroring and simultaneously &quot;
               &quot;be neither able to retrieve the property with &#x27;hasADMaterialProperty&#x27; nor through &quot;
               &quot;a default property&quot;);
  if (!hasMaterialProperty&lt;Real&gt;(&quot;regular_mat_prop&quot;) &amp;&amp;
      !defaultMaterialProperty&lt;Real&gt;(deducePropertyName(&quot;regular_mat_prop&quot;)))
    mooseError(
        &quot;It should be impossible to get a regular property without erroring and simultaneously &quot;
        &quot;be neither able to retrieve the property with &#x27;hasMaterialProperty&#x27; nor through &quot;
        &quot;a default property&quot;);
}

ADReal
ADMatDiffusionTest::computeQpResidual()
{
  if (_prop_to_use == &quot;AdAd&quot;)
    return _ad_diff_from_ad_prop[_qp] * _grad_test[_i][_qp] * _grad_u[_qp];
  else if (_prop_to_use == &quot;RegReg&quot;)
    return _regular_diff_from_regular_prop[_qp] * _grad_test[_i][_qp] * _grad_u[_qp];
  else
    mooseError(&quot;Oops&quot;);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="15886f17-e2c2-4356-a27c-f8dda004d4b2"><div class="modal-content"><h4>(doc/test/include/kernels/ADMatDiffusionTest.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;ADKernel.h&quot;
#include &quot;MaterialProperty.h&quot;

class ADMatDiffusionTest : public ADKernel
{
public:
  static InputParameters validParams();

  ADMatDiffusionTest(const InputParameters &amp; parameters);

protected:
  virtual ADReal computeQpResidual();

  const ADMaterialProperty&lt;Real&gt; &amp; _ad_diff_from_ad_prop;
  const MaterialProperty&lt;Real&gt; &amp; _regular_diff_from_regular_prop;
  const MooseEnum _prop_to_use;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#84caaaf4-f597-4bb8-9a19-39e37ca2d23a" class="tooltipped" data-position="left" data-tooltip="Solving Non - linear Systems">Solving Non - linear Systems</a></li><li><a href="#a348960b-62ea-4a81-a007-965aa5abf445" class="tooltipped" data-position="left" data-tooltip="Jacobian Definition">Jacobian Definition</a></li><li><a href="#aa449cde-a8ae-4481-b45d-af9eaaef13d1" class="tooltipped" data-position="left" data-tooltip="Solving Linear Systems">Solving Linear Systems</a></li><li><a href="#cbbc40bb-24d6-4ff0-838a-ac29db93953e" class="tooltipped" data-position="left" data-tooltip="Augmenting Sparsity">Augmenting Sparsity</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>